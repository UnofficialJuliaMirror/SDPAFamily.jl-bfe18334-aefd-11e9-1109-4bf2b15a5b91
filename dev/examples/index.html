<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SDPAFamily.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDPAFamily.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li class="current"><a class="toctext" href>Examples</a><ul class="internal"><li><a class="toctext" href="#Optimal-guessing-probability-for-a-pair-of-quantum-states-1">Optimal guessing probability for a pair of quantum states</a></li></ul></li><li><a class="toctext" href="../issues/">Possible Issues &amp; Troubleshooting</a></li><li><a class="toctext" href="../reference/">Developer reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Examples</a></li></ul><a class="edit-page" href="https://github.com/ericphanson/SDPAFamily.jl/blob/master/docs/src/examples.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><div></div><p>Here is a simple optimization problem formulated with Convex.jl:</p><pre><code class="language-julia-repl">julia&gt; using SDPAFamily, LinearAlgebra

julia&gt; using Convex # ] add https://github.com/ericphanson/Convex.jl#MathOptInterface

julia&gt; y = Semidefinite(3)
Variable
size: (3, 3)
sign: real
vexity: affine
id: 125…274

julia&gt; p = maximize(lambdamin(y), tr(y) &lt;= 5; numeric_type = BigFloat)
maximize
└─ lambdamin (concave; positive)
   └─ 3×3 real variable (id: 125…274)
subject to
└─ &lt;= constraint (affine)
   ├─ sum (affine; real)
   │  └─ diag (affine; real)
   │     └─ …
   └─ 5

current status: OPTIMIZE_NOT_CALLED

julia&gt; solve!(p, SDPAFamily.Optimizer(presolve=true))

julia&gt; p.optval
1.666666666666666666666666666665476989753299163954502444310422560355435839218525</code></pre><h2><a class="nav-anchor" id="Optimal-guessing-probability-for-a-pair-of-quantum-states-1" href="#Optimal-guessing-probability-for-a-pair-of-quantum-states-1">Optimal guessing probability for a pair of quantum states</a></h2><p>In physics, a <em>state</em> represents a possible configuration of a physical system. In quantum mechanical systems with finitely many degrees of freedom, states are represented by <em>density matrices</em>, which are <span>$d\times d$</span> matrices with complex entries that are positive semi-definite and have trace equal to one. States can be <em>measured</em>; mathematically, a measurement with <span>$n$</span> possible outcomes is represented by a set of measurement operators <span>$\{E_j\}_{j=1}^n$</span>, where each <span>$E_j$</span> is a <span>$d\times d$</span> matrix. For example, imagine an experiment in which a charged particle is released in a magnetic field such that it will hit either a detector on the left or a detector on the right. This corresponds to a measurement of the particle with two outcomes, and hence two measurement operators <span>$\{E_1, E_2\}$</span>, which to the left and right detector.</p><p>In order for <span>$\{E_j\}_{j=1}^n$</span> to be a valid set of measurement operators, each <span>$E_j$</span> must be positive semi-definite, and the family <span>$\{E_j\}_{j=1}^n$</span> must have the property that <span>$\sum_{j=1}^n E_j = I_d$</span>, the <span>$d\times d$</span> identity matrix. If the state of the system is represented by <span>$\rho$</span>, and a measurement with measurement operators <span>$\{E_j\}_{j=1}^n$</span> is performed, then outcome <span>$j$</span> is obtained with probability <span>$\operatorname{tr}[\rho E_j]$</span>.</p><p>Consider the case where <span>$d=2$</span> (i.e. the states are <em>qubits</em>), and the state of the system is either represented by <span>$\rho_1 = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 0 \end{pmatrix}$</span> or by <span>$\rho_2 = \frac{1}{2}\begin{pmatrix} 1 &amp; -i \\ i &amp; 1 \end{pmatrix}$</span>, but we don&#39;t know which; let&#39;s say there is a referee who flipped a fair coin, and then prepared the system in either <span>$\rho_1$</span> or <span>$\rho_2$</span>. We will perform a measurement of the system, and then use the outcome to make a guess about the state of the system.  What is the measurement that gives the highest probability of correctly determining which state the system is in, and what&#39;s the optimal probability?</p><p>We will perform a measurement with measurement operators <span>$E_1$</span> and <span>$E_2$</span>. If we get outcome <span>$1$</span>, we will guess the system is in state <span>$\rho_1$</span> and and if we obtain outcome 2, we guess the system is in state <span>$\rho_2$</span>. Then the probability of guessing correctly is</p><div>\[p_\text{guess}(E_1, E_2) = \frac{1}{2}\operatorname{tr}(\rho_1  E_1) + \frac{1}{2}\operatorname{tr}(\rho_2  E_2)\]</div><p>since there is a 50% chance of the system being in state <span>$\rho_1$</span>, in which case we guess correctly when we get outcome 1 (which occurs with probability <span>$\operatorname{tr}(\rho_1 E_1)$</span>), and a 50% chance of the system being in state <span>$\rho_2$</span>, in which case we guess correctly when we get outcome <span>$2$</span>.</p><p>Our goal now is to choose the optimal measurement operators to have the the best chance of guessing correctly. That is, we aim to maximize the above expression over all choices of <span>$E_1$</span> and <span>$E_2$</span> such that <span>$\{E_1, E_2\}$</span> is a valid set of measurement operators. This is a semidefinite program, which can be solved e.g. with SDPAFamily.jl In this simple example with only two states to discriminate between, the problem can be solved analytically, and the solution is related to the trace distance between the two states. This problem specifically is Example 3.2.1 of the <a href="http://users.cms.caltech.edu/~vidick/teaching/120_qcrypto/LN_Week3.pdf">edX Quantum Cryptography notes by Thomas Vidick</a>. It can be seen that the optimal guessing probability is</p><div>\[p_\text{guess} = \frac{1}{2} + \frac{1}{2 \sqrt{2}}\]</div><p>Let us see to what accuracy we can recover that result using the SDPA solvers.</p><pre><code class="language-julia-repl">julia&gt; using SDPAFamily, Printf

julia&gt; using Convex # ] add https://github.com/ericphanson/Convex.jl#MathOptInterface

julia&gt; ρ₁ = Complex{BigFloat}[1 0; 0 0]
2×2 Array{Complex{BigFloat},2}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im

julia&gt; ρ₂ = (1//2)*Complex{BigFloat}[1 -im; im 1]
2×2 Array{Complex{BigFloat},2}:
 5.0e-01+0.0im          0.0-5.0e-01im
     0.0+5.0e-01im  5.0e-01+0.0im

julia&gt; E₁ = ComplexVariable(2, 2)
Variable
size: (2, 2)
sign: complex
vexity: affine
id: 354…665

julia&gt; E₂ = ComplexVariable(2, 2)
Variable
size: (2, 2)
sign: complex
vexity: affine
id: 158…111

julia&gt; problem = maximize( real((1//2)*tr(ρ₁*E₁) + (1//2)*tr(ρ₂*E₂)),
                           [E₁ ⪰ 0, E₂ ⪰ 0, E₁ + E₂ == Diagonal(ones(2))];
                           numeric_type = BigFloat );

julia&gt; p_guess = 1//2 + 1/(2*sqrt(big(2)))
8.535533905932737622004221810524245196424179688442370182941699344976831196155298e-01

julia&gt; for variant in (:sdpa, :sdpa_dd, :sdpa_qd, :sdpa_gmp)
           solve!(problem, SDPAFamily.Optimizer(silent = true, presolve = true, variant = variant))
           error = abs(problem.optval - p_guess)
           print(&quot;$variant solved the problem with an absolute error of &quot;)
           @printf(&quot;%.2e.\n&quot;, error)
       end
sdpa solved the problem with an absolute error of 1.30e-07.
sdpa_dd solved the problem with an absolute error of 4.75e-16.
sdpa_qd solved the problem with an absolute error of 3.13e-17.
sdpa_gmp solved the problem with an absolute error of 2.70e-31.</code></pre><p>Here, we have solved the problem four times, once with each variant of the SDPA family of optimizers supported by this package. We can see that SDPA-GMP has solved the problem to an accuracy of <span>$\sim 10^{-31}$</span>, far exceeding machine precision.</p><p>As usual with semidefinite programs, we can recover a set of optimal measurements:</p><pre><code class="language-julia-repl">julia&gt; evaluate(E₁)
2×2 Array{Complex{BigFloat},2}:
 8.53553e-01+0.0im                  0.0+3.53553e-01im
         0.0-3.53553e-01im  1.46447e-01+0.0im

julia&gt; evaluate(E₂)
2×2 Array{Complex{BigFloat},2}:
 1.46447e-01+0.0im                  0.0-3.53553e-01im
         0.0+3.53553e-01im  8.53553e-01+0.0im</code></pre><p>Note that this is an example where the presolve routine is essential to getting good results:</p><pre><code class="language-julia-repl">julia&gt; for variant in (:sdpa, :sdpa_dd, :sdpa_qd, :sdpa_gmp)
           solve!(problem, SDPAFamily.Optimizer(silent = true, presolve = false, variant = variant))
           error = abs(problem.optval - p_guess)
           print(&quot;$variant solved the problem with an absolute error of &quot;)
           @printf(&quot;%.2e.\n&quot;, error)
       end
┌ Warning: Problem status SLOW_PROGRESS; solution may be inaccurate.
└ @ Convex ~/.julia/packages/Convex/r4w0m/src/MOI_solve.jl:199
sdpa solved the problem with an absolute error of 1.17e-02.
┌ Warning: Problem status ITERATION_LIMIT; solution may be inaccurate.
└ @ Convex ~/.julia/packages/Convex/r4w0m/src/MOI_solve.jl:199
sdpa_dd solved the problem with an absolute error of 8.54e-01.
┌ Warning: Problem status ITERATION_LIMIT; solution may be inaccurate.
└ @ Convex ~/.julia/packages/Convex/r4w0m/src/MOI_solve.jl:199
sdpa_qd solved the problem with an absolute error of 8.54e-01.
┌ Warning: Problem status ITERATION_LIMIT; solution may be inaccurate.
└ @ Convex ~/.julia/packages/Convex/r4w0m/src/MOI_solve.jl:199
sdpa_gmp solved the problem with an absolute error of 8.54e-01.</code></pre><p>We can see that without the presolve routine, we have only recovered the true solution up to errors of size <span>$\sim 10^{-1}$</span> for <code>:sdpa</code> variant. All other variants have failed to produce a result due to redundant constraints and returned with default value 0.</p><p>This problem is revisited at very high precision in <a href="../usage/#Changing-parameters-and-solving-at-very-high-precision-1">Changing parameters &amp; solving at very high precision</a>.</p><footer><hr/><a class="previous" href="../usage/"><span class="direction">Previous</span><span class="title">Usage</span></a><a class="next" href="../issues/"><span class="direction">Next</span><span class="title">Possible Issues &amp; Troubleshooting</span></a></footer></article></body></html>
